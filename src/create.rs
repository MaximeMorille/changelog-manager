use std::error::Error;

use slug::slugify;

use crate::{
    entry::{Entry, Serializable},
    fs_manager::write_entry,
    git_info::GitInfo,
};

/// Starts the interactive mode to create a changelog entry.
///
/// # Arguments
///
/// * `info` - A `GitInfo` struct containing information about the current git state.
///
/// # Panics
///
/// This function will panic as it is not implemented yet.
pub fn start_interactive_mode(info: GitInfo) {
    panic!("Not implemented yet");
}

/// Creates a changelog entry and writes it to a file.
///
/// The filename is generated by slugifying the provided branch name.
///
/// # Arguments
///
/// * `entry` - A reference to an `Entry` struct that contains the changelog entry data.
/// * `branch` - A reference to a `String` that represents the branch name.
///
/// # Example
///
/// ```rust
/// let entry = Entry::new("Added new feature", "Description of the new feature");
/// let branch = String::from("feature/new-feature");
/// create_changelog_entry(&entry, &branch);
/// ```
pub fn create_changelog_entry(entry: &Entry, branch: &String) -> Result<(), Box<dyn Error>> {
    let filename = slugify(branch);
    let buffer = entry.to_json()?;
    Ok(write_entry(filename, buffer)?)
}

#[cfg(test)]
mod tests {
    use crate::{
        create::start_interactive_mode,
        git_info::{GitInfo, GitInfoProvider},
    };

    #[test]
    #[should_panic]
    fn test_start_interactive_mode() {
        start_interactive_mode(GitInfo::new().expect("Should be able to get git info"));
    }
}
